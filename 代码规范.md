# 代码规范
## 一、整洁代码
```
1. 概念     
	代码正确            
	简洁明了        
	清晰易读          
	短小精确
```
## 二、命名
```
1. 准确：
	名字与意义匹配             
	易于区别           
2. 实用 	
	使用读的出来的名称   	
	使用可搜索的名称         
3. 明确    	
	一个概念对应一个词  	
	不用双关语   	
	使用有意义的语境   
```
## 三、函数   
```
1. 短小      
2. 职责单一      
3. 一块代码中，函数的抽象层级需一致      
4. 函数命名规范（参照二）      
5. 参数尽可能少      
6. 如果函数需要的参数要求数量有多种，应考虑将其封装成类      
7. 实用异常类代替返回错误码，抽离try/catch代码块，使代码更加简洁
```
## 四、注释    
```
1. 少用注释，尽可能通过规范的代码来表达      
2. 不使用无意义的注释      
3. 必要的注释： 
	法律信息	
	提供信息的注释	
	对代码意图进行解释的注释	
	警示信息，防止踩坑	
	TODO注释：未来得及完成的部分     
4. 对于无用的代码应直接删除而不是注释
```
## 五、格式    
```
1. 为什么需要规范格式	
	易维护	
	易拓展       
2. 垂直格式	
	行数少，短小精悍	
	概念隔离，不同的的概念/逻辑 
	代码实用空行隔离	
	相关靠近：对于关系紧密的代码，尽量写在一起       
3. 水平格式	
	缩进、对齐
```
## 六、对象与数据结构    
```
1. 区别：	
	过程式代码便于在不改动既有数据结构的前提下添加新函数
	面向对象代码便于在不改动既有函数的前提下添加新类        
	亦即：	过程式代码难以添加新数据结构，因为必须修改所有函数
	面向对象代码难以添加新函数，因为必须修改所有类
```
## 七、错误处理 
```
1. 使用异常而非返回码：	更加美观、整洁       
2. 使用不可控异常
	可控异常的代价是违反开放／闭合原则，因为你需要在使用的地方捕获异常 
3. 在异常发生的地方添加环境说明：	
	这样当异常发生的时候就可以根据这些信息定位异常原因       
4. 不返回null 也不传递null	
	这样在接收的时候不需要进行空值检查
```
## 八、边界
```
    翻了下原书，边界是Boundaries   
    对于这个名字，开始不是大理解，就算现在看来也还是觉得不直观      
	标题略晦涩：作者的意思应该是让我们让自己的代码和第三方库代码不要耦合太紧密，需有清新的边界       
	对于第三方类库给的学习建议是：探索性地学习测试，以此熟悉类库，写出良好的代码
```
## 九、单元测试  
```
1. TDD定律 
	在编写不能通过的单元测试前，不可编写生产代码
	只可编写刚好无法通过的单元测试，不能编译也算不通过
	只可编写刚好足以通过当前失败测试的生产代码----- 
	这三条写的有点绕，我的理解就是：要把测试代码当生产代码来写，测试也很重要
2. 五大规则(F.I.R.S.T)	
	快速：就是代码质量要好，高效	
	独立：不同测试之间应相互独立	
	可重复：就是在各种环境中都可测试通过	自足验证：测试不依赖手工操作来知晓是否通过	及时：测试应在生产代码之前进行编写十、类      主要注意一个点，类应短小，可通过以下两种方式达到此目的：
	1. 权责单一：一个类的权责不应太多，太多则需考虑拆成多个类了
	2. 高内聚：类的实体变量应尽可能少，类中方法尽可能多地使用到这些变量
```
## 十一、系统       
```
1. 系统构造与使用分开		
	工厂：使用工厂方法自行决定何时创建实例，但是构造细节却在其他地方	
	依赖注入：当A对B有依赖时，A中不负责B的实例化（这就是类的权责单一原则） 
2. 本章的后半部分提到的AOP，AspectJ等内容都以Spring，EJB等框架为例
```
## 十二、跌进  
```
跌进这一章提到的点不多       
1. 运行所有的测试：为能方便测试，我们的生产代码也要足够短小，耦合度低 
2. 重构：在写代码过程中要及时重构，保持代码的优雅       
3. 不可重复：已有的代码要利用起来，消除重复       
4. 表达力强：这应该是一个目标或是结果，做好前边的工作自然而然可以达到
```
## 十三、并发编程    
```
1. 为什么：它可以将“目的”和“时机”分离，进行解耦      
2. 并发防御原则	
	单一权责：主要关注一点，并发相关的代码应分离出来        为此，三点建议：         
		1).限制数据作用域
		2).使用数据副本：这不就是ThreadLocsal么～～    
		3).线程应尽可能地独立       
3. 学习已有类库：Java中的并发包之类
```